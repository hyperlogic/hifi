<!
//  Skinning.slh
//  libraries/render-utils/src
//
//  Created by Sam Gateau on 10/5/15.
//  Copyright 2013 High Fidelity, Inc.
//
//  Distributed under the Apache License, Version 2.0.
//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html
!>
<@if not SKINNING_SLH@>
<@def SKINNING_SLH@>

// Use dual quaternion skinning
// Must match #define SKIN_DQ in Model.h
<@def SKIN_DQ@>

const int MAX_CLUSTERS = 128;
const int INDICES_PER_VERTEX = 4;

<@if SKIN_DQ@>

struct NonRigidDualQuaternion {
    mat4 nonRigidMat;
    vec4 rigidDualQuatReal;
    vec4 rigidDualQuatDual;
};

layout(std140) uniform skinClusterBuffer {
    NonRigidDualQuaternion clusterTransforms[MAX_CLUSTERS];
};

mat4 dualQuatToMat4(vec4 real, vec4 dual) {
    float twoRealXSq = 2.0 * real.x * real.x;
    float twoRealYSq = 2.0 * real.y * real.y;
    float twoRealZSq = 2.0 * real.z * real.z;
    float twoRealXY = 2.0 * real.x * real.y;
    float twoRealXZ = 2.0 * real.x * real.z;
    float twoRealXW = 2.0 * real.x * real.w;
    float twoRealZW = 2.0 * real.z * real.w;
    float twoRealYZ = 2.0 * real.y * real.z;
    float twoRealYW = 2.0 * real.y * real.w;
    vec4 col0 = vec4(1.0 - twoRealYSq - twoRealZSq,
                     twoRealXY + twoRealZW,
                     twoRealXZ - twoRealYW,
                     0.0);
    vec4 col1 = vec4(twoRealXY - twoRealZW,
                     1.0 - twoRealXSq - twoRealZSq,
                     twoRealYZ + twoRealXW,
                     0.0);
    vec4 col2 = vec4(twoRealXZ + twoRealYW,
                     twoRealYZ - twoRealXW,
                     1.0 - twoRealXSq - twoRealYSq,
                     0.0);
    vec4 col3 = vec4(2.0 * (-dual.w * real.x + dual.x * real.w - dual.y * real.z + dual.z * real.y),
                     2.0 * (-dual.w * real.y + dual.x * real.z + dual.y * real.w - dual.z * real.x),
                     2.0 * (-dual.w * real.z - dual.x * real.y + dual.y * real.x + dual.z * real.w),
                     1.0);

    return mat4(col0, col1, col2, col3);
}

void dualQuaternionLinearBlending(ivec4 skinClusterIndex, vec4 skinClusterWeight, out vec4 resultReal, out vec4 resultDual) {

    // linearly blend
    resultReal = vec4(0.0, 0.0, 0.0, 0.0);
    resultDual = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 polarityReference = clusterTransforms[skinClusterIndex[0]].rigidDualQuatReal;
    for (int i = 0; i < INDICES_PER_VERTEX; i++) {
        vec4 real = clusterTransforms[(skinClusterIndex[i])].rigidDualQuatReal;
        vec4 dual = clusterTransforms[(skinClusterIndex[i])].rigidDualQuatDual;

        float clusterWeight = skinClusterWeight[i];

        // to ensure that we rotate along the shortest arc, reverse dual quaternions with negative polarity.
        float dqClusterWeight = clusterWeight;
        if (dot(real, polarityReference) < 0.0) {
            dqClusterWeight = -clusterWeight;
        }

        resultReal += real * dqClusterWeight;
        resultDual += dual * dqClusterWeight;
    }

    // normalize
    float norm = length(resultReal);
    resultReal /= norm;
    resultDual /= norm;
}

// dual quaternion linear blending
void skinPosition(ivec4 skinClusterIndex, vec4 skinClusterWeight, vec4 inPosition, out vec4 skinnedPosition) {

    // phase one: transform by nonRigid part.
    vec4 newPosition = vec4(0.0, 0.0, 0.0, 0.0);
    for (int i = 0; i < INDICES_PER_VERTEX; i++) {
        mat4 nonRigidMat = clusterTransforms[(skinClusterIndex[i])].nonRigidMat;
        float clusterWeight = skinClusterWeight[i];
        newPosition += nonRigidMat * inPosition * clusterWeight;
    }

    // phase two: linear blend of rigid dual quaternion.
    vec4 rigidDualQuatReal;
    vec4 rigidDualQuatDual;
    dualQuaternionLinearBlending(skinClusterIndex, skinClusterWeight, rigidDualQuatReal, rigidDualQuatDual);

    // conversion from dual quaternion to 4x4 matrix.
    mat4 rigidMat = dualQuatToMat4(rigidDualQuatReal, rigidDualQuatDual);

    // apply rigidMat from phase two to result of phase one.
    skinnedPosition = rigidMat * newPosition;
}

void skinPositionNormal(ivec4 skinClusterIndex, vec4 skinClusterWeight, vec4 inPosition, vec3 inNormal,
                        out vec4 skinnedPosition, out vec3 skinnedNormal) {

    // phase one: transform by nonRigid part.
    vec4 newPosition = vec4(0.0, 0.0, 0.0, 0.0);
    for (int i = 0; i < INDICES_PER_VERTEX; i++) {
        mat4 nonRigidMat = clusterTransforms[(skinClusterIndex[i])].nonRigidMat;
        float clusterWeight = skinClusterWeight[i];
        newPosition += nonRigidMat * inPosition * clusterWeight;
    }

    // phase two: linear blend of rigid dual quaternion.
    vec4 rigidDualQuatReal;
    vec4 rigidDualQuatDual;
    dualQuaternionLinearBlending(skinClusterIndex, skinClusterWeight, rigidDualQuatReal, rigidDualQuatDual);

    // conversion from dual quaternion to 4x4 matrix.
    mat4 rigidMat = dualQuatToMat4(rigidDualQuatReal, rigidDualQuatDual);

    // apply rigidMat from phase two to result of phase one.
    skinnedPosition = rigidMat * newPosition;

    skinnedNormal = vec3(rigidMat * vec4(inNormal, 0));
}

void skinPositionNormalTangent(ivec4 skinClusterIndex, vec4 skinClusterWeight, vec4 inPosition, vec3 inNormal, vec3 inTangent,
                               out vec4 skinnedPosition, out vec3 skinnedNormal, out vec3 skinnedTangent) {

    // phase one: transform by nonRigid part.
    vec4 newPosition = vec4(0.0, 0.0, 0.0, 0.0);
    for (int i = 0; i < INDICES_PER_VERTEX; i++) {
        mat4 nonRigidMat = clusterTransforms[(skinClusterIndex[i])].nonRigidMat;
        float clusterWeight = skinClusterWeight[i];
        newPosition += nonRigidMat * inPosition * clusterWeight;
    }

    // phase two: linear blend of rigid dual quaternion.
    vec4 rigidDualQuatReal;
    vec4 rigidDualQuatDual;
    dualQuaternionLinearBlending(skinClusterIndex, skinClusterWeight, rigidDualQuatReal, rigidDualQuatDual);

    // conversion from dual quaternion to 4x4 matrix.
    mat4 rigidMat = dualQuatToMat4(rigidDualQuatReal, rigidDualQuatDual);

    // apply rigidMat from phase two to result of phase one.
    skinnedPosition = rigidMat * newPosition;

    skinnedNormal = vec3(rigidMat * vec4(inNormal, 0));
    skinnedTangent = vec3(rigidMat * vec4(inTangent, 0));
}

<@else@>  // SKIN_DQ

layout(std140) uniform skinClusterBuffer {
    mat4 clusterTransforms[MAX_CLUSTERS];
};

void skinPosition(ivec4 skinClusterIndex, vec4 skinClusterWeight, vec4 inPosition, out vec4 skinnedPosition) {
    vec4 newPosition = vec4(0.0, 0.0, 0.0, 0.0);

    for (int i = 0; i < INDICES_PER_VERTEX; i++) {
        mat4 clusterMatrix = clusterTransforms[(skinClusterIndex[i])];
        float clusterWeight = skinClusterWeight[i];
        newPosition += clusterMatrix * inPosition * clusterWeight;
    }

    skinnedPosition = newPosition;
}

void skinPositionNormal(ivec4 skinClusterIndex, vec4 skinClusterWeight, vec4 inPosition, vec3 inNormal,
                        out vec4 skinnedPosition, out vec3 skinnedNormal) {
    vec4 newPosition = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 newNormal = vec4(0.0, 0.0, 0.0, 0.0);

    for (int i = 0; i < INDICES_PER_VERTEX; i++) {
        mat4 clusterMatrix = clusterTransforms[(skinClusterIndex[i])];
        float clusterWeight = skinClusterWeight[i];
        newPosition += clusterMatrix * inPosition * clusterWeight;
        newNormal += clusterMatrix * vec4(inNormal.xyz, 0.0) * clusterWeight;
    }

    skinnedPosition = newPosition;
    skinnedNormal = newNormal.xyz;
}

void skinPositionNormalTangent(ivec4 skinClusterIndex, vec4 skinClusterWeight, vec4 inPosition, vec3 inNormal, vec3 inTangent,
                               out vec4 skinnedPosition, out vec3 skinnedNormal, out vec3 skinnedTangent) {
    vec4 newPosition = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 newNormal = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 newTangent = vec4(0.0, 0.0, 0.0, 0.0);

    for (int i = 0; i < INDICES_PER_VERTEX; i++) {
        mat4 clusterMatrix = clusterTransforms[(skinClusterIndex[i])];
        float clusterWeight = skinClusterWeight[i];
        newPosition += clusterMatrix * inPosition * clusterWeight;
        newNormal += clusterMatrix * vec4(inNormal.xyz, 0.0) * clusterWeight;
        newTangent += clusterMatrix * vec4(inTangent.xyz, 0.0) * clusterWeight;
    }

    skinnedPosition = newPosition;
    skinnedNormal = newNormal.xyz;
    skinnedTangent = newTangent.xyz;
}

<@endif@> // if SKIN_DQ

<@endif@> // if not SKINNING_SLH
